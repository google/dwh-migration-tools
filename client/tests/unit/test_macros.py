# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Macro processing unit tests."""
import pathlib
import re

from bqms_run.macros import (
    MacroExpanderRouter,
    PatternMacroExpander,
    SimpleMacroExpander,
    ParameterAwareMacroExpander
)


def test_basic_replacement():
    """Macro expansion with a basic mapping."""
    expander = MacroExpanderRouter(
        {
            "*.sql": PatternMacroExpander(
                mapping={"a": "alpha", "b": "bravo"},
                pattern="\\${(\\w+)}",
            )
        }
    )
    input_text = "abcdef ${a}.${b} ghijkl"
    expanded = expander.expand(pathlib.Path("abc.sql"), input_text)
    assert expanded == "abcdef alpha.bravo ghijkl"
    un_expanded = expander.un_expand(pathlib.Path("abc.sql"), expanded)
    assert un_expanded == input_text


def test_missing_replacement():
    """Error message should be present if a macro cannot be expanded."""
    expander = MacroExpanderRouter(
        {
            "*.sql": PatternMacroExpander(
                mapping={"a": "alpha", "b": "bravo"},
                pattern="\\$\\{(\\w+)\\}",
            )
        }
    )
    input_text = "abcdef ${a}.${b} ${c} ghijkl"
    expanded = expander.expand(pathlib.Path("abc.sql"), input_text)
    assert expanded == "abcdef alpha.bravo ${c} ghijkl"
    assert expander.all_messages()[0].startswith("Could not expand '${c}'")


def test_generator_replacement():
    """Macro expansions that are missing from the mapping can be generated by
    a user-supplied function."""
    expander = MacroExpanderRouter(
        {
            "*.sql": PatternMacroExpander(
                mapping={},
                pattern="\\$\\{(\\w+)\\}",
                generator=lambda path, text: "##" + str(path) + "_" + text + "##",
            )
        }
    )
    input_text = "abc${something}def"
    expanded = expander.expand(pathlib.Path("abc.sql"), input_text)
    assert expanded == "abc##abc.sql_something##def"
    un_expanded = expander.un_expand(pathlib.Path("abc.sql"), expanded)
    assert un_expanded == input_text


def test_ambiguous_unexpand():
    """An error message should be generated when multiple macros map to the
    same expansion, and un-expansion is attempted."""
    expander = MacroExpanderRouter(
        {
            "*.sql": PatternMacroExpander(
                mapping={"a": "abc", "b": "abc"},
                pattern="\\$\\{(\\w+)\\}",
                generator=lambda path, text: "xyz",
            )
        }
    )
    input_text = "${a}.${b} ${c}.${d}"
    expanded = expander.expand(pathlib.Path("abc.sql"), input_text)
    assert expanded == "abc.abc xyz.xyz"
    un_expanded = expander.un_expand(pathlib.Path("abc.sql"), expanded)
    assert un_expanded in (
        "${a}.${a} ${c}.${c}",
        "${a}.${a} ${d}.${d}",
        "${b}.${b} ${c}.${c}",
        "${b}.${b} ${d}.${d}",
    )
    messages = expander.all_messages()
    messages.sort()
    assert messages[0].startswith("The value 'abc'")
    assert messages[1].startswith("The value 'xyz'")


def test_unintended_unexpand():
    """It is possible to un-expand a something that was not actually a macro
    expansion. This is difficult to detect and warn about without generating
    false-positives"""
    expander = MacroExpanderRouter(
        {
            "*.sql": PatternMacroExpander(
                mapping={"a": "abc"},
                pattern="\\$\\{(\\w+)\\}",
            )
        }
    )
    input_text = "${a} abc"
    expanded = expander.expand(pathlib.Path("abc.sql"), input_text)
    assert expanded == "abc abc"
    un_expanded = expander.un_expand(pathlib.Path("abc.sql"), expanded)
    assert un_expanded == "${a} ${a}"


def test_unexpand_generator():
    """The un_generator parameter allows the user to customize the un-expansion
    process."""
    expander = MacroExpanderRouter(
        {
            "*.sql": PatternMacroExpander(
                pattern="\\$\\{(\\w+)\\}",
                mapping={},
                generator=lambda path, macro_name: "PARAM_"
                + macro_name.lower()
                + "_PARAM",
                un_generator=lambda path, replacement, macro_name: "{"
                + re.match("PARAM_(.+)_PARAM", replacement).group(1)
                + "}",
            )
        }
    )
    input_text = "${a} abc"
    expanded = expander.expand(pathlib.Path("abc.sql"), input_text)
    assert expanded == "PARAM_a_PARAM abc"
    un_expanded = expander.un_expand(pathlib.Path("abc.sql"), expanded)
    assert un_expanded == "{a} abc"


def test_basic_expand():
    """Test basic macro expansion"""
    expander = MacroExpanderRouter(
        {
            "*.sql": SimpleMacroExpander(
                mapping={"${a}": "alpha", "${b}": "bravo"},
            )
        }
    )
    input_text = "abcdef ${a}.${b} ghijkl"
    expanded = expander.expand(pathlib.Path("abc.sql"), input_text)
    assert expanded == "abcdef alpha.bravo ghijkl"
    un_expanded = expander.un_expand(pathlib.Path("abc.sql"), expanded)
    assert un_expanded == input_text

def test_complex_1():
    expander = MacroExpanderRouter(
        {
            "*.sql": ParameterAwareMacroExpander(
                pattern="(\\[\\$\\w+\\])",
                value_stripper='__bq__\\d+__(.*)__bq__\\d+__',
                mapping={"[$table1]": "__bq__0__ABCDEF__bq__0__"},
                source_bind_generator=lambda arg: "@"+arg,
                target_bind_generator=lambda arg: arg
            )
        }
    )

    input_text="SELECT * FROM WXYZ.[$table1]"
    expanded = expander.expand(pathlib.Path("abc.sql"), input_text)
    assert expanded == "SELECT * FROM WXYZ.__bq__0__ABCDEF__bq__0__"
    un_expanded = expander.un_expand(pathlib.Path("abc.sql"), expanded)
    assert un_expanded == input_text

def test_complex_2():
    expander = MacroExpanderRouter(
        {
            "*.sql": ParameterAwareMacroExpander(
                pattern="\\[\\$(\\w+)\\]",
                value_stripper='__bq__\\d+__(.*)__bq__\\d+__',
                mapping={
                    "table1": "__bq__0__ABCDEF__bq__0__",
                    "limit_val1": "__bq__1__5__bq__1__"
                },
                source_bind_generator=lambda arg: "@"+arg,
                target_bind_generator=lambda arg: arg
            )
        }
    )

    input_text = "SELECT * FROM WXYZ.[$table1] LIMIT [$limit_val1]"
    expanded = expander.expand(pathlib.Path("abc.sql"), input_text)
    assert expanded == "SELECT * FROM WXYZ.__bq__0__ABCDEF__bq__0__ LIMIT @__bq__1__5__bq__1__"
    expanded = "SELECT * FROM WXYZ.__bq__0__ABCDEF__bq__0__ LIMIT __bq__1__5__bq__1__"
    un_expanded = expander.un_expand(pathlib.Path("abc.sql"), expanded)
    assert un_expanded == input_text

def test_unexpand_after_database_added():
    expander = MacroExpanderRouter(
        {
            "*.sql": ParameterAwareMacroExpander(
                pattern="(\\[\\$\\w+\\])",
                value_stripper='__bq__\\d+__(.*)__bq__\\d+__',
                mapping={
                    "[$table]": "__bq__0__table__bq__0__",
                },
                source_bind_generator=lambda arg: "@"+arg,
                target_bind_generator=lambda arg: arg
            )
        }
    )

    input_text = "CREATE TABLE [$table](a INT64);"
    expanded = expander.expand(pathlib.Path("abc.sql"), input_text)
    assert expanded == "CREATE TABLE __bq__0__table__bq__0__(a INT64);"
    expanded = "CREATE TABLE db_name.__bq__0__table__bq__0__(a INT64);"
    un_expanded = expander.un_expand(pathlib.Path("abc.sql"), expanded)
    expected_output = "CREATE TABLE db_name.[$table](a INT64);"
    assert un_expanded == expected_output



